# Java并发机制的底层实现原理
Java代码会编译成字节码，字节码会被类加载器加载到JVM里，JVM将字节码转换为汇编指令在CPU上执行所以Java中的并发机制依赖于JVM的实现与CPU的指令

## volatile的应用
synchronized和violate在并发编程中有着重要作用，violate是轻量级的synchronized，它保证了多处理器开发时的共享变量的可见性。当一个线程修改一个共享变量时，另外一个线程可以读到这个修改的值，violate比synchronized使用和执行成本更低，它不会引起线程上下文的切换和调度

### volatile的定义与实现原理
volatile定义：
>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。

CPU与内存通信模型：
>为了提高处理速度，处理器不直接与内存进行通信，而是将需要的内存数据读取到CPU内部缓存（L1、L2或者其他）中后在内部缓存中进行操作，但不知道何时会将内部缓存写回主内存

缓存行：
>缓存中k可以分配的最小存储单元

实现原理：
>如果变量被violate修饰，JVM将字节码转化为汇编指令时,会多出一条Lock前缀的指令,此指令的作用有两点
>>1. 将当前处理器的缓存行数据写回到系统主内存
>>2. 这个写回操作会导致其他处理器中缓存了该内存地址的数据无效

### volatile的使用优化
并发包中队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能
```java
// 队列中的头部节点
private transient final PaddedAtomicReference<QNode> head;
// 队列中的尾部节点 
private transient final PaddedAtomicReference<QNode> tail;

static final class PaddedAtomicReference <T> extends AtomicReference <T> {
// 使用很多4个字节的引用追加到64个字节
    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
    PaddedAtomicReference(T r) {
        super(r);
    }
}
public class AtomicReference <V> implements java.io.Serializable {
    private volatile V value;
    // 省略其他代码
｝

```

原理：
>每个对象引用占4个字节，PaddedAtomicReference追加了15个对象，使该对象的占用64个字节。对于Intel酷睿7、Pentium M等处理器的L1、L2缓存的高速缓存行是64个字节宽，如果队列的头尾结点不足64个字节的话，会读取到同一个缓存行中，当一个处理器试图修改头/尾结点时，会锁定该缓存行，在缓存一致性的机制下，会导致其他处理器不能访问尾结点，队列的入队出队会频繁访问头尾结点，所以严重影响效率，将头尾结点追加到64字节，避免加载到同一个缓存行内，使头尾结点修改时不会相互锁定

下列不适用将volatile变量追加到64字节的情况：
1. 缓存行非64字节宽的处理器
>P6系列、奔腾处理器缓存32个字节宽
2. 共享变量不会被频繁地写

---
## synchronized实现原理与应用

Java中每一个对象都可以作为锁。具体表现为以下3种形式：
1. 对于普通同步方法，锁当前实例对象
2. 对于静态同步方法，锁当前类的Class对象
3. 对于同步方法块，锁synchronized内配置的对象

###基本概念
* 机器码（机器语言）
> 由机器指令集构成，能直接被机器执行（用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合）。一条指令就是机器语言的一条语句，是一组有意义的二进制代码，指令的基本格式如操作码字段和地址码字段，操作码指明操作指令的性质和作用，地址码给出操作数或者操作数的地址

* 竞态条件
>两个或者多个进程读写某些共享数据，而最后的结果取决于进程运行的准确时序，称为竞态条件。

* 临界区
> 临界区意味着这个区域是敏感的，因为一旦进程运行到这个区域，那么意味着会对公共数据区域或者文件进行操作，也意味着有可能有其它进程也正运行到了临界区。如果能够采用适当的方式，使得这两个进程不会同时处于临界区，那么就能避免竞态条件。

* 原语
>内核提供给核外调用的过程或者函数，原语在执行过程中不允许中断。原语由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性。即原语的执行必须是连续的，中途不允许被中断

* 操作系统提供的同步原语

    1.sleep 
    > 将调用的进程阻塞
                            
    2.wakeup
    > 另外一个进程调用wakeup(xx) 去唤醒xx进程
    
    3.信号量（semaphore）
    > 由于一个进程的阻塞和唤醒是在不同的进程中进行的，所以存在中断的可能，比如进程A由进程B唤醒，但由于时钟中断，进程B先执行了wakeup，之后进程A才执行sleep，此时没有进程去唤醒进程A。
    >
    > 因此需要额外引入一个变量来记录，此变量记录了唤醒的次数。每次被其他线程唤醒，此值+1，进行sleep时，如果被其他线程唤醒过了，则不需要进入阻塞状态
    >
    > 对信号量有两种操作down(P操作)、up(V操作)
    >
    > down操作对应sleep，他会先检测信号量是否大于0，若大于0则-1，此时无需阻塞，相当于消耗了一次wakeup；弱信号量为0，则进入阻塞状态
    >
    > up操作对应wakeup，进行 up 操作后，如果发现有进程阻塞在这个信号量上，那么系统会选择其中一个进程将其唤醒，此时信号量的值不需要变化，但被阻塞的进程已经少了一个；如果 up 操作时没有进程阻塞在信号量上，那么它会将信号量的值加1。
    
    4.互斥量（mutex）
    > 互斥量（mutex）其实是信号量的一种特例，它的值只有 0 和 1，当我们不需要用到信号量的计数能力时，我们可以使用互斥量，实际上也意味着临界区值同一时间只允许一个进程进入，而信号量是允许多个进程同时进入临界区的。
    >

* java中的monitor机制           
>使用mutex、semaphore进行开发需要小心的控制down和up操作，所以抽象出更高层次的原语monitor，此原语操作系统不提供，一般由各种语言自行实现
>
>monitor机制的特点就是同一时间只有一个进程/线程能进入monitor种定义的临界区，这使的monitor能达到互斥的效果，但仅仅这样是不足够的，无法进入临界区的进程/线程应该在等待，等待到必要的时候被唤醒，所以monitor也需要提供这样的机制
>
>monitor机制需要几个条件
>* 临界区
>>临界区用来定义互斥的区域
>* monitor对象
>>monitor对象维护基于mutex原语实现的锁以及相应的保存处在等待状态的线程队列，处于锁池的线程队列，以及对外提供两个API，wait和notify来让线程进入阻塞状态以及之后被唤醒

### Java语言对monitor的实现
1. synchronized指定临界区
2. 在使用synchronized时，往往需要指定一个对象与之关联，修饰实例方法时关联this对象，修饰类方法时，关联this.class 此对象为monitor object
3. Java语言种Object对象实现了wait、notify、notifyAll三个Native方法（JVM内部基于C++实现）来使线程进入阻塞状态以及唤醒、Java对象在内存中保存分为三部分对象头、实例数据、对齐充填，其中对象头中包括锁信息，所以Java中任意的对象都可以用作monitor object

等待队列(本是Object里的方法，但影响了线程)
![等待队列](../../resource/wait_notify.png)


### Java对象头
synchronized用的锁是存储在Java对象头内，如果对象头是数组类型，则虚拟机用3个字宽保存对象头，如果对象头是非数组类型，虚拟机用2个字宽保存对象头。在32位虚拟机中，1字宽等于4字节即32位

Java对象头内容
|长度|内容|说明|
|:-:|:-:|:-:|
|32/64bit|Mark word|含有类的Hashcode、分代年龄、锁标志信息|
|32/64bit|Class Metadata Address|类元数据地址|
|32/64bit|Array length|数组长度（如果是数组）|

MarkWord存储结构（32位）
|锁状态|25bit|4bit|1bit是否为偏向锁|2bit锁标志位|
|:-:|:-:|:-:|:-:|:-:|
|无锁状态|对象hashcode|分代年龄|0|01|
|轻量级锁|指向栈中锁记录的指针|同左|同左|00|
|重量级锁|指向互斥量的指针|同左|同左|10|
|GC标记|空|空|空|11|
|偏向锁|线程ID23bit+Epoch（加锁时间戳）2bit|分代年龄|1|01|

### 锁的升级与对比
Java1.6为了提高获得锁和释放锁的效率，新增了偏向锁和轻量级锁，锁的级别一共有4种：无锁、偏向锁、轻量级锁、重量级锁。锁随着竞争状态只能升级不能降级

1. 偏向锁

    大多数情况下，锁不仅不存在竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，而引入了偏向锁。当一个线程访问同步块时，会在对象头和栈帧中的锁记录里存储线程ID，以后再该线程进入和退出时，会测试对象头中是否存储指向当前线程的偏向锁，如果测试成功，则表示已获得过该锁，如果测试失败，则再测试是否为偏向锁，如果是偏向锁则使用CAS将线程id设置为当前访问的线程，如果不是偏向锁，则使用 *CAS* 竞争锁
    >CAS(compare and swap) 乐观的轻量级的机制。有三个参数 V(内存中的值) E（你期望内容中的值） N(新值) 当V==E时，将V = N，当V!=E时返回此时V的值，允许再次尝试，现在处理器已提供原子化的CAS操作

    1. 偏向锁的撤销
    
        偏向锁使用一种等竞争出现才释放锁的机制。当测试当前对象头为偏向锁切通过CAS将线程ID设置为当前访问的线程失败时，说明由多个线程竞争锁，此时需要撤销偏向锁。偏向锁的撤销需要等待全局安全点（此时没有正在执行的字节码），先暂停拥有偏向锁的进程，然后将对象头以及栈中的锁记录恢复为无锁状态并标记需要升级，然后唤醒该线程进行偏向锁的升级
    
    2. 关闭偏向锁
    
        由于偏向锁再出现竞争时，会进行撤销以及升级，如果实际情况经常发生锁的竞争可以关闭使用偏向锁（JAVA6、7中默认使用偏向锁，但在应用程序启动几秒之后才激活，JVM参数关闭延迟：-XX: BiaseLockingStartupDelay=0）,JVM参数关闭使用偏向锁-XX:UseBiaseLocking = false，此时程序默认进入轻量级锁
    
