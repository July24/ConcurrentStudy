# Java内存模型基础

## 并发编程的两个问题
1. 线程之间如何通信

    存在两种机制，共享内存和消息传递。共享内存模型里线程之间共享程序的公共状态，通过读写内存中的公共状态进行隐式通信。消息传递模型里，线程之间通信必须通过发送消息

2. 线程之间如何同步

    同步指控制不同线程间操作发生的相对顺序。共享内存模型中，同步是显式的，必须指定某个方法或者某段代码需要在线程间互斥执行。消息传递模型中，由于消息发送在消息接受前，因此同步是隐式的。

Java采用的是共享内存模型

## Java内存模型的抽象结构

堆、方法去在线程之间共享，虚拟机栈、本地方法栈、程序计数器非线程共享

Java线程之间的通信由Java内存模型（JMM）来控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见。线程之间的变量存储在主内存，每个线程都有一个私有的本地内存，本地内存中存储了该线程读/写共享内存变量的副本。本地内存是JMM的抽象概念，并不真实存在

所以线程间的通信，必须经历两个步骤，线程A把本地内存中更新的共享变量刷新回主内存，线程B读取线程A已更新过的变量

## 源代码到指令序列的重排序
为了提高性能，编译器和处理器会对指令进行重排序。

重排序分为三种：
1. 编译器优化的重排序。不改变单线程程序语义的情况下进行重排序
2. 指令级并行的重排序。处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变机器指令的执行顺序
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，加载和存储操作可能乱序执行

1为编译器重排序，2、3为处理器重排序，JMM会禁止特定的编译器重排序和通过加入内存屏障来禁止处理器重排序，为程序员在不同平台，不同处理器上提供一直的内存可见性

## happens-before
JDK5开始 使用新的JSR-133内存模型。使用happens-before来阐述操作间的内存可见性。在JMM中如果一个操作执行的结果需要对另一个操作可见（并不保证前一个操作一定在后一个操作前执行），这两个操作需要存在happens-before关系。

与程序员密切关系的happens-before规则：
1. 程序顺序规则。一个线程中的每个操作，happens-before该线程后续的任意操作
2. 监视器锁规则。对一个锁的解锁，happens-before随后对这个锁的加锁
3. volatile变量。对一个volatile变量的写，happens-before于任意后续对这个变量的写
4. 传递性。A happens-before B， B happens-before C，则 A happens-before C。

happens-before规则对应于一个或者多个编译器、处理器重排序规则。避免了为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则